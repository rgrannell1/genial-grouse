<!DOCTYPE html>
<html>

<head>
	<title></title>

</head>
<style type="text/css">
	canvas  {
		margin-left: 400px;
	}
	* {
		cursor: none;
	}
</style>
<body>

	<canvas id = "canvas" width = "600" height = "600">

	</canvas>

</body>
<script type="text/javascript">

	var can = document.getElementById("canvas")

	var ctx = can.getContext("2d")

	var constants = ( function () {

		var self = {}

		self.dx = 1.2
		self.cloud = {
			"width": 140,
			"height": 140 / Math.pow(1.613, 3),
			"cloudFrequency": 1/10
		}
		self.bounds = {
			'x0': -self.cloud.width,
			'x1': can.width + self.cloud.width,
			'y0': -50,
			'y1': can.height + 50,
		}

		self.gravity = 9.8,

		self.colours = {
			"blue": "#3498db",
			"white": "#ecf0f1",
			"black": "black"
		}

		self.hero = {
			"width": 15,
			"height": 40
		}
		self.score = {
			"x0": 100,
			"y0": 50
		}
		self.frameTime =
			1/60

		self.asMagnitude =
			function (interval) {
				return interval / 120
			}

		self.asVelocity =
			function (velocity) {
				var terminalVelocity = 8

				if (velocity > 0) {
					return Math.min(velocity, terminalVelocity)
				} else {
					return Math.max(velocity, -terminalVelocity)
				}
			}

		return self
	} )()

	var keyCodes = {
		'space': 32
	}

	var utils = {
		'timer':
			function (milliseconds) {

				var genesis = (new Date).getTime()

				return function () {
					return (new Date).getTime() > (genesis + milliseconds)
				}
			},
		'trueWithOdds':
			function (p) {
				return Math.random() < p
			},
		'randBetween':
			function (lower, upper) {
				return (Math.random() * (upper-lower)) + lower
			},
		'flatmap':
			function (coll, fn) {

				var out = []

				for (var ith = 0; ith < coll.length; ith++) {
					out = out.concat( fn(coll[ith]) )
				}
				return out
			}
	}

	// the initial state
	var state = {
		'cloudIsReady':
			function () {return true},

		'clouds': [],
		'hero':
			{
				x0: 200,
				x1: 200 + constants.hero.width,
				y0: 200,
				y1: 200 + constants.hero.height,
				angle: 0,

				vx: 0,
				vy: 0,
				ax: 0,
				ay: 0,

				isDead:
					false,

				positionType:
					'flying',

				last: -1,

				jumpStart: {

				}
			},

		// reactions are temporally ordered.
		'reactions': [],
		'score':
			{
				value: 0,
				x0: constants.score.x0,
				y0: constants.score.y0
			},
		'nextCloud': 0
	}

	var react = {
		"addClouds":
			function (state) {
				const coinFlip = utils.trueWithOdds(constants.cloud.cloudFrequency)

				if (coinFlip && state.cloudIsReady()) {

					state.cloudIsReady = utils.timer(6000)

					var y0 = utils.randBetween(
						1 / 3 * constants.bounds.y1,
						2 / 3 * constants.bounds.y1)

					const newCloud = [{
						'x0': constants.bounds.x1,
						'x1': constants.bounds.x1 + constants.cloud.width,

						'y0': y0,
						'y1': y0 + constants.cloud.height,

						'cloudId': state.nextCloud
					}]

					state.nextCloud += 1
					state.clouds = state.clouds.concat(newCloud)
				}

				return state
			},
		"scrollCloudsLeft":
			function (state) {

				state.clouds = state.clouds.map(function (cloud) {

					cloud.x0 -= constants.dx
					cloud.x1 -= constants.dx

					return cloud
				})

				return state

			},
		"removeOldClouds":
			function (state) {

				state.clouds = state.clouds.filter(function (cloud) {
					return cloud.x0 > constants.bounds.x0
				})

				return state
			},
		"clipWings":
			function (state) {
				/*
					transition from the flying state to the falling state.
				*/

				var hero = state.hero

				hero.positionType = 'falling'
				state.hero = hero

				return state
			},
		'flyAlong':
			function (state) {
				// bob along like a bird

				var hero = state.hero

				hero.x0 =
					Math.max(hero.x0, 0)
				hero.x1 =
					Math.max(hero.x1, 0)

				hero.y0 =
					hero.y0 + (0.4 * Math.sin(hero.angle))
				hero.y1 =
					hero.y1 + (0.4 * Math.sin(hero.angle))

				hero.angle =
					hero.angle + 0.05

				state.hero = hero

				return state
			},
		'standStill':
			function (state) {

				var hero = state.hero

				if (hero.positionType === "standing") {
					hero.x0 = hero.x0 - constants.dx
					hero.x1 = hero.x1 - constants.dx
				}

				state.hero = hero

				return state
			},
		'checkOnPlatform':
			function (state){
				/*
				*/
				var hit = false
				var hero = state.hero

				var match = utils.flatmap(state.clouds, function (cloud) {

					var xAligned = state.hero.x1 > cloud.x0 && state.hero.x0 < cloud.x1
					var yAligned = state.hero.y1 > cloud.y0 && state.hero.y0 < cloud.y1

					var xTooCloseToEdge = hero.x1 < cloud.x0 + 5

					if (yAligned && xAligned && xTooCloseToEdge) {
						hit = true
					} else if (xAligned && yAligned) {
						return cloud
					} else {
						return []
					}
				})

				if (match.length == 0) {
					hero.positionType = 'falling'
				} else if (hit) {
					// reverse the state direction.

					hero.vx = -hero.vx

					hero.x0 -= 3
					hero.x1 -= 3

					hero.positionType = "dying"

					hit = false

				} else {
					hero.positionType = 'standing'

					if (hero.last !== match[0].cloudId) {

						state.score.value = state.score.value + 1
						hero.last = match[0].cloudId
					}

					// vertically translate the player, to make
					// stand on platform.
					hero.y0 = match[0].y0 + 1 - constants.hero.height
					hero.y1 = match[0].y0 + 1
				}

				state.hero = hero

				return state
			},
		'addGravity':
			function (state) {

				var hero = state.hero

				hero.x0 = Math.max(hero.x0 + hero.vx, 0)
				hero.x1 = Math.max(hero.x1 + hero.vx, 0)

				hero.y0 = hero.y0 + hero.vy
				hero.y1 = hero.y1 + hero.vy

				hero.vy = constants.asVelocity(hero.vy + (constants.gravity * constants.frameTime))

				state.hero = hero

				return state
			},
		'killWhenOffscreen':
			function (state) {
				/*
					check if the player is offscreen,
					and if he or she is append an event.
				*/

				var hero = state.hero

				if (hero.y1 > constants.bounds.y1 || hero.x0 < constants.bounds.x0 ||
					hero.y0 < constants.bounds.y0 || hero.x1 > constants.bounds.x1) {
					state.hero.isDead = true
				}
				state.hero = hero

				return state
			},
		'beginJumpPowerup':
			function (time) {
				return function (state) {
					/*
						register that we are getting ready to jump.
					*/

					if (state.hero.positionType === 'standing') {
						state.jumpStart = {
							'time': time
						}
					}

					return state
				}
			},
		'jump':
			function (x, y, time) {
				/*
					jump.
				*/
				return function (state) {

					if (state.hero.positionType !== "standing") {
						return state
					}

					var magnitude = constants.asMagnitude(time - state.jumpStart.time)
					var hero = state.hero

					// squelch accidental taps.
					if (magnitude > constants.asMagnitude(40)) {

						var mouse = {
							'x': x - canvas.offsetLeft,
							'y': y - canvas.offsetTop
						}

						var dist = {
							'x': mouse.x - hero.x0,
							'y': mouse.y - hero.y1
						}

						var angle = Math.atan(dist.y / dist.x)

						hero.vx = constants.asVelocity(
							magnitude * (Math.cos(angle)) )

						hero.vy = constants.asVelocity(
							magnitude * (Math.sin(angle)) )

						hero.y0 -= 1
						hero.y1 -= 1

						hero.positionType = 'falling'
					}

					state.jumpStart = {}
					state.hero = hero

					return state
				}
			}


	}

	var _update = function (state) {
		/*
			given the state at t, calculate the state at t + dt
			*/

			var events = [
				react.scrollCloudsLeft,
				react.removeOldClouds,
				react.addClouds,
				react.killWhenOffscreen
			]

			if (state.hero.positionType === 'flying') {

				events = events.concat([react.flyAlong])

			} else {


				if (state.hero.positionType === 'falling') {

					events = events.concat([react.addGravity])

				} else {

					events = events.concat([react.standStill])

				}
				events = events.concat([react.checkOnPlatform])
			}

			state.reactions = state.reactions.concat(events)

			/*
				consume every event in the queue, in order.
			*/

			for (var ith = 0; ith < state.reactions.length; ith++) {
				var reaction = state.reactions[ith]

				if (reaction) {
					state = reaction(state)
				}
			}
			state.reactions = []

			return state
	}

	var draw = {
		'cloud':
			function (state) {
				/*
					plot each cloud.
				*/

				ctx.fillStyle = constants.colours.white

				state.clouds.forEach(function (cloud) {
					ctx.fillRect(cloud.x0, cloud.y0, constants.cloud.width, constants.cloud.height)
				})
			},
		'hero':
			function (state) {

				var hero = state.hero

				ctx.fillStyle = constants.colours.white
				ctx.fillRect(
					hero.x0, hero.y0, constants.hero.width, constants.hero.height)
			},
		'score':
			function (state) {

 				ctx.font = "30px Monospace";
				ctx.fillText(
					state.score.value + "",
					constants.score.x0, constants.score.y0)
			},
		'deathScreen':
			function (state) {

				ctx.fillStyle = 'rgba(0,0,0,0.4)'

				ctx.fillRect(
					constants.bounds.x0, constants.bounds.y0,
					constants.bounds.x1, constants.bounds.y1)

				ctx.fillStyle = constants.colours.blue

				ctx.fillRect(
					constants.bounds.x0, 200,
					constants.bounds.x1, 100)

 				ctx.font = "20px Monospace";
				ctx.fillStyle = constants.colours.white

				value = state.score.value

				if (value < 3) {
					var message = "Try Harder. Score: " + value
				} else if (value < 10) {
					var message = ". Score: " + value
				} else {
					var message = "Well done. Score: " + value
				}

				ctx.fillText(
					"Try harder." +
					"Score: " + state.score.value,
					constants.score.x0, 265)
			}
	}

	var _draw = function (state) {
		/*
			given the current state draw each entity to the screen.
		*/

		canvas.width = canvas.width

		ctx.fillStyle = constants.colours.blue
		ctx.strokeStyle = constants.colours.black

		ctx.fillRect(0, 0, canvas.width, canvas.height)

	    // draw each rectangle to the canvas.
		draw.cloud(state)

		draw.hero(state)
		draw.score(state)

		ctx.stroke();
	}

	window.addEventListener('keydown', function (event) {
		if (event.keyCode === keyCodes.space) {

			state.reactions =
				state.reactions.concat([react.clipWings])

		}
	})
	window.addEventListener('mousedown', function (event) {

		state.reactions =
			state.reactions.concat([react.beginJumpPowerup((new Date).getTime() )])
	})

	window.addEventListener('mouseup', function (event) {

		state.reactions =
			state.reactions.concat([react.jump(
				event.pageX, event.pageY, (new Date).getTime() )])
	})


	var loop = function () {
		/*
			repeatedly update the state.
		*/

		if (!state.hero.isDead) {
			state = _update(state);
			_draw(state)
		} else {
			draw.deathScreen(state)
			clearInterval(GAMEID)
		}
	}
	var GAMEID = setInterval(loop, 1000/60)

</script>
</html>
